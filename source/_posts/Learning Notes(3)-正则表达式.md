title: 学习笔记 - 正则表达式
date: 2015-11-18 15:05:29
tags: [Learning Notes,JavaScript]
categories: Learning Notes 
---
### 正则表达式直接量
正则表达式直接量定义为包含在一对斜杠（/）之间的字符，例如：var pattern =/s$/;(即匹配以s结尾的字符串)

用构造函数RegExp（）也可以，例：var pattern = new RegExp("s$");

>ECMAScript 3规定：
>一个正则表达式直接量会在执行到它的时候转换为一个RegExp对象，同一段代码所表示的正则表达式直接量的每次运算都返回同一个对象。
>ECMAScript 5规定：
>同一段代码的正则表达式直接量的每次运算都返回一个新的对象。


例如，在Firefox 3.6中遵循的是ECMAScript 3规范，Firefox 4+中遵循的是ECMAScript 5规范，PS： 在ECMAScript 6 规范中，我还没有学习到最新关于正则表达式直接量的部分。（示例来自于《javaScript权威指南》）
```
function getReg(){
	var re = /[a-z]/;
	re.foo = 'bar';
	return re;
}

var reg = getReg();
reg2 = getReg();
console.log(reg === reg2);//在Firefox3.6中，true；在Firefox4+中，false；
reg.foo = 'baz';
console.log(reg2.foo);在Firefox3.6中，返回‘baz’；在Firefox4+中，返回‘bar’；
```

**tips:**
 1. 如果想要在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀'\'，这是一条通行规则；
 2.  如果不记得哪些符号需要反斜杠转义，可以在每个标点符号前都加上反斜杠；
 3.  许多字母和数字在反斜杠作为前缀的时候有特殊含义 ,所以对想要按照直接量进行匹配的字母和数字，尽量不要用反斜杠对其进行转义；
 4. 要想在正则表达式中按照直接量匹配反斜线本身，则必须使用反斜杠将其转义。
 
### 字符类（character class）
 直接将字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。
 
 例如：/[abc]/,即匹配‘a’‘b’‘c’中的任意一个。
 
 可以通过“^”符号来否定字符类，它匹配所有不包含在方括号内的字符。
字符类可以使用连字符来表示字符范围。例如：/[a-z]/，即匹配小写拉丁字母；/[a-zA-Z0-9]/，即匹配拉丁字母和数字。

**正则表达式的字符类**

| 字符   | 匹配                                             |
| ------ | ------------------------------------------------ |
| [...]  | 方括号内的任意字符                               |
| [^...] | 不在方括号内的任意字符                           |
| .      | 除换行符和其他Unicode行终止符之外的任意字符      |
| \w     | 任何ASCII字符组成的单词，等价于[a-zA-Z0-9_]      |
| \W     | 任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9_] |
| \s     | 任何Unicode空白符                                |
| \S     | 任何非Unicode空白符的字符                        |
| \d     | 任何ASCII数字，等价于[0-9]                       |
| \D     | 任何非ASCII数字，等价于[^0-9]                    |
| [\b]   | 退格直接量（特列）                               |

**正则表达式的重复字符语法（贪婪）**

| 字符  | 匹配                                   |
| ----- | -------------------------------------- |
| {n,m} | 匹配前一项至少n次，最多m次             |
| {n,}  | 匹配前一项至少n次                      |
| {n}   | 匹配前一项n次                          |
| ？    | 匹配前一项0或1次，即可选，等价于{0,1}  |
| +     | 匹配前一项1或多次，即可选，等价于{1，} |
| *     | 匹配前一项0或多次，即可选，等价于{0,}  |

例如：

| 正则表达式   | 意义                                         |
| ------------ | -------------------------------------------- |
| /\d{2,4}/    | 匹配2-4个数字                                |
| /\w{3}\d?/   | 精确匹配三个单词和一个可选数字               |
| /\s+java\s+/ | 匹配前后带有一个或者多个空格的字符串‘java’ |
| /[^(]*/      | 匹配0个或者多个非左括号的字符                |

**非贪婪的重复**
非贪婪匹配，只需在带匹配的字符后跟随一个问号，如：“？？”、“+？”、“*？”或者“{1,5}？”。
使用非贪婪的匹配模式所得的结果可能与预期不同。如：/a+?b/，它匹配的是尽可能少的a和一个b。当它用来匹配“aaab”时，你希望它能匹配一个a和最后一个b，但实际上，这个模式缺匹配了整个字符串，该模式的匹配结果和贪婪一模一样。这是因为正则表达式的模式匹配总会寻找第一个可能不匹配的位置，由于该匹配是从该字符串中第一个字符开始，因为不考虑字符串中子串更短的匹配。

**字符“|”**
用于分隔供选择的字符。例如： /ab|cd|ef/ 可以匹配"ab"或"cd"或"ef"，/\d{3}|[a-z]{4}/ 可以匹配三个数字或者死歌小写字母
PS：选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择相匹配就忽略了右边的匹配项。例如： /a|ab/ 匹配字符串”ab“的时候，它只能匹配第一个字符‘a’。

**正则表达式中圆括号的作用**

 1. 把单独的相组合成子表达式；
 2. 在完整的模式中定义一个子模式。当一个正则表达式成功的和目标字符串相匹配的时，可以从目标串中抽取和圆括号中子模式相匹配的部分；
 3. 带圆括号的表达式，允许在同一正则表达式的后部引用前面的自表达式。通过在字符”\“后加以为或者多位数字来实现。

**正则表达式的锚元素**
最常用的锚元素”^“用来匹配字符串的开始，”$“用以匹配字符串的结束。

”（？：“和”）“仅仅用来分组，并不生成引用,即匹配不包括。

**正则表达式中的锚字符**

| 字符  | 含义                                                             |
| ----- | ---------------------------------------------------------------- |
| ^     | 匹配字符串的开头，在多行检索时，匹配一行的开头                   |
| $     | 匹配字符串的结尾，在多行检索中，匹配一行的结尾                   |
| \b    | 匹配一个单词的边界                                               |
| \B    | 匹配非单词边界                                                   |
| (?=p) | 零宽正向先行断言，要求接下来的字符都与p匹配，但不包括P的那些字符 |
| (?!p) | 零宽负向先行断言，要求接下来的字符都不与p匹配                    |

### 用于模式匹配的String方法

 1. String.search()
 它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1。search()方法不支持全局检索，因为它忽略正则表达式参数中的修饰符g。
 
 2. String.replace()
 用以执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。
 如果replace()的第一个参数不是正则表达式而是一个字符串的话，则直接搜索这个字符串，而不是像search（）一样先通过RegExp（）将它转换成正则表达式，
 
 3. String.match（）
 它的唯一参数是一个正则表达式，返回的是一个由匹配结果组成的数组。
 如果该正则表达式设置了修饰符g，则该方法返回的数组包含字符串中的所有匹配结果。
 即使match（）方法执行的不是全局检索，它返回的也是一个数组，在这种情况下，数组的第一个元素是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。
 例如：使用如下代码解析一个URL：
 
```
var url = /(\w+):\/\/([\w.]+)\/(\S*)/;
var text = 'lalaal //write.blog.csdn.net/mdeditor';
var result = text.match(url);
console.log(result);//chrome下运行结果：["//write.blog.csdn.net/mdeditor", "http", "write.blog.csdn.net", "mdeditor", index: 7, input: "lalaal //write.blog.csdn.net/mdeditor"]
console.log(result[0]);////write.blog.csdn.net/mdeditor
console.log(result[1]);//http
console.log(result[2]);//write.blog.csdn.net
console.log(result[3]);//mdeditor
console.log(result[4]);//undefined
```
 4. String.split()
 用以将调用它的字符串拆分为一个子串组成的数组。
 例如：
 
```
console.log('lalaal //write.blog.csdn.net/mdeditor'.split(/\s|:|\.|\//));
//chrome下运行结果：["lalaal", "http", "", "", "write", "blog", "csdn", "net", "mdeditor"]
```
### RegExp对象
var regExp = new RegExp('\\d{5}'，'g');
第一个参数是正则表达式的主体部分，不论是字符串直接量还是正则表达式，都需要使用'\'作为转义字符的前缀，因此，当RegExp（）传入一个字符串表述的正则表达式的时候，必须将'\'替换成'\\'。第二个参数是可选的，修饰符。

**电子邮箱地址的正则表达式为：**
**/^([\w\-\.]+)@([\w\-\.]+)[\.][a-zA-Z]{2,4}$/**
**或者/^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)[\.][a-zA-Z]{2,4}$/**
([\-\w]+) \.?匹配任何ASCII字符组成的单词（大小写字母和数字或'_'）或'-'，一次或多次，可选符号'.'（即0次或者1次）
(([\-\w]+)\.?)+ 上述字符串的出现一次或者多次
[a-z]{2,4}$ 结尾匹配域名后缀，2-4个小写字母。

